# Lunos API TypeScript Client Library

## Overview
This is a comprehensive TypeScript client library for the Lunos API that provides easy access to various AI services including chat completions, image generation, audio generation, and embeddings. The library follows SOLID principles and best practices for maintainability and extensibility.

## Architecture & SOLID Principles

### Single Responsibility Principle (SRP)
- Each class has a single, well-defined responsibility
- `LunosClient` - Main client orchestrator
- `ChatService` - Handles chat completions
- `ImageService` - Handles image generation
- `AudioService` - Handles audio generation
- `EmbeddingService` - Handles embeddings
- `ModelService` - Handles model information

### Open/Closed Principle (OCP)
- Base classes are open for extension but closed for modification
- New AI services can be added by extending base classes
- Configuration and options are extensible

### Liskov Substitution Principle (LSP)
- All service implementations can be substituted for their base interfaces
- Consistent error handling across all services

### Interface Segregation Principle (ISP)
- Clients only depend on interfaces they actually use
- Separate interfaces for different capabilities (streaming, non-streaming, etc.)

### Dependency Inversion Principle (DIP)
- High-level modules depend on abstractions, not concrete implementations
- Dependency injection for configuration and services

## File Structure

```
src/
├── client/
│   ├── LunosClient.ts              # Main client class
│   ├── config/
│   │   ├── ClientConfig.ts         # Configuration interface
│   │   └── DefaultConfig.ts        # Default configuration
│   └── errors/
│       ├── LunosError.ts           # Base error class
│       ├── APIError.ts             # API-specific errors
│       └── ValidationError.ts      # Validation errors
├── services/
│   ├── base/
│   │   ├── BaseService.ts          # Base service class
│   │   └── ServiceInterface.ts     # Service interface
│   ├── ChatService.ts              # Chat completion service
│   ├── ImageService.ts             # Image generation service
│   ├── AudioService.ts             # Audio generation service
│   ├── EmbeddingService.ts         # Embedding service
│   └── ModelService.ts             # Model information service
├── types/
│   ├── chat.ts                     # Chat-related types
│   ├── image.ts                    # Image-related types
│   ├── audio.ts                    # Audio-related types
│   ├── embedding.ts                 # Embedding-related types
│   ├── models.ts                   # Model-related types
│   └── common.ts                   # Common types
├── utils/
│   ├── validation.ts               # Validation utilities
│   ├── streaming.ts                # Streaming utilities
│   └── file.ts                     # File handling utilities
└── index.ts                        # Main export file
```

## Core Implementation

### 1. Main Client Class (LunosClient.ts)

```typescript
import { LunosConfig } from './config/ClientConfig';
import { ChatService } from './services/ChatService';
import { ImageService } from './services/ImageService';
import { AudioService } from './services/AudioService';
import { EmbeddingService } from './services/EmbeddingService';
import { ModelService } from './services/ModelService';
import { LunosError } from './errors/LunosError';

export class LunosClient {
  private config: LunosConfig;
  private chatService: ChatService;
  private imageService: ImageService;
  private audioService: AudioService;
  private embeddingService: EmbeddingService;
  private modelService: ModelService;

  constructor(config: Partial<LunosConfig> = {}) {
    this.config = this.mergeConfig(config);
    this.initializeServices();
  }

  private mergeConfig(userConfig: Partial<LunosConfig>): LunosConfig {
    return {
      baseUrl: 'https://api.lunos.tech',
      apiKey: '',
      timeout: 30000,
      retries: 3,
      retryDelay: 1000,
      ...userConfig
    };
  }

  private initializeServices(): void {
    this.chatService = new ChatService(this.config);
    this.imageService = new ImageService(this.config);
    this.audioService = new AudioService(this.config);
    this.embeddingService = new EmbeddingService(this.config);
    this.modelService = new ModelService(this.config);
  }

  // Service getters
  get chat() { return this.chatService; }
  get image() { return this.imageService; }
  get audio() { return this.audioService; }
  get embedding() { return this.embeddingService; }
  get models() { return this.modelService; }

  // Health check
  async healthCheck(): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.baseUrl}/v1`);
      return response.ok;
    } catch (error) {
      return false;
    }
  }
}
```

### 2. Base Service Class (BaseService.ts)

```typescript
import { LunosConfig } from '../config/ClientConfig';
import { LunosError } from '../errors/LunosError';

export abstract class BaseService {
  protected config: LunosConfig;

  constructor(config: LunosConfig) {
    this.config = config;
  }

  protected async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.config.baseUrl}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.config.apiKey}`,
      ...options.headers
    };

    const requestOptions: RequestInit = {
      ...options,
      headers,
      signal: AbortSignal.timeout(this.config.timeout)
    };

    try {
      const response = await fetch(url, requestOptions);
      
      if (!response.ok) {
        throw new LunosError(
          `API request failed: ${response.status} ${response.statusText}`,
          response.status
        );
      }

      return await response.json();
    } catch (error) {
      if (error instanceof LunosError) {
        throw error;
      }
      throw new LunosError(`Network error: ${error.message}`, 0);
    }
  }

  protected async makeStreamRequest(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ReadableStream<Uint8Array>> {
    const url = `${this.config.baseUrl}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.config.apiKey}`,
      ...options.headers
    };

    const requestOptions: RequestInit = {
      ...options,
      headers,
      signal: AbortSignal.timeout(this.config.timeout)
    };

    try {
      const response = await fetch(url, requestOptions);
      
      if (!response.ok) {
        throw new LunosError(
          `API request failed: ${response.status} ${response.statusText}`,
          response.status
        );
      }

      if (!response.body) {
        throw new LunosError('No response body for streaming request', 0);
      }

      return response.body;
    } catch (error) {
      if (error instanceof LunosError) {
        throw error;
      }
      throw new LunosError(`Network error: ${error.message}`, 0);
    }
  }
}
```

### 3. Chat Service (ChatService.ts)

```typescript
import { BaseService } from './base/BaseService';
import { ChatCompletionRequest, ChatCompletionResponse, ChatMessage } from '../types/chat';
import { StreamProcessor } from '../utils/streaming';

export class ChatService extends BaseService {
  async createCompletion(
    request: ChatCompletionRequest
  ): Promise<ChatCompletionResponse> {
    return this.makeRequest<ChatCompletionResponse>('/v1/chat/completions', {
      method: 'POST',
      body: JSON.stringify(request)
    });
  }

  async createCompletionStream(
    request: ChatCompletionRequest
  ): Promise<ReadableStream<Uint8Array>> {
    const streamRequest = { ...request, stream: true };
    return this.makeStreamRequest('/v1/chat/completions', {
      method: 'POST',
      body: JSON.stringify(streamRequest)
    });
  }

  async createCompletionWithStream(
    request: ChatCompletionRequest,
    onChunk?: (chunk: string) => void
  ): Promise<ChatCompletionResponse> {
    const stream = await this.createCompletionStream(request);
    const processor = new StreamProcessor();
    return processor.processStream(stream, onChunk);
  }

  async getGeneration(id: string): Promise<any> {
    return this.makeRequest(`/v1/chat/generation/${id}`);
  }

  // Convenience methods
  async chat(
    messages: ChatMessage[],
    model?: string,
    options?: Partial<ChatCompletionRequest>
  ): Promise<ChatCompletionResponse> {
    return this.createCompletion({
      messages,
      model,
      ...options
    });
  }

  async chatStream(
    messages: ChatMessage[],
    model?: string,
    onChunk?: (chunk: string) => void,
    options?: Partial<ChatCompletionRequest>
  ): Promise<ChatCompletionResponse> {
    return this.createCompletionWithStream({
      messages,
      model,
      ...options
    }, onChunk);
  }
}
```

### 4. Image Service (ImageService.ts)

```typescript
import { BaseService } from './base/BaseService';
import { ImageGenerationRequest, ImageGenerationResponse } from '../types/image';

export class ImageService extends BaseService {
  async generateImage(
    request: ImageGenerationRequest
  ): Promise<ImageGenerationResponse> {
    return this.makeRequest<ImageGenerationResponse>('/v1/image/generations', {
      method: 'POST',
      body: JSON.stringify(request)
    });
  }

  // Convenience methods
  async generate(
    prompt: string,
    model?: string,
    options?: Partial<ImageGenerationRequest>
  ): Promise<ImageGenerationResponse> {
    return this.generateImage({
      prompt,
      model,
      ...options
    });
  }

  async generateWithSize(
    prompt: string,
    width: number,
    height: number,
    model?: string,
    options?: Partial<ImageGenerationRequest>
  ): Promise<ImageGenerationResponse> {
    return this.generateImage({
      prompt,
      width,
      height,
      model,
      ...options
    });
  }
}
```

### 5. Audio Service (AudioService.ts)

```typescript
import { BaseService } from './base/BaseService';
import { AudioGenerationRequest, AudioGenerationResponse } from '../types/audio';
import { FileUtils } from '../utils/file';

export class AudioService extends BaseService {
  async generateAudio(
    request: AudioGenerationRequest
  ): Promise<AudioGenerationResponse> {
    const response = await this.makeRequest<{ audioData: string; contentType: string }>(
      '/v1/audio/generations',
      {
        method: 'POST',
        body: JSON.stringify(request)
      }
    );

    // Convert base64 to buffer
    const audioBuffer = Buffer.from(response.audioData, 'base64');
    
    return {
      audioBuffer,
      contentType: response.contentType,
      filename: `audio_${Date.now()}.${this.getFileExtension(response.contentType)}`
    };
  }

  async generateAudioToFile(
    request: AudioGenerationRequest,
    filepath: string
  ): Promise<string> {
    const result = await this.generateAudio(request);
    await FileUtils.saveBufferToFile(result.audioBuffer, filepath);
    return filepath;
  }

  // Convenience methods
  async textToSpeech(
    text: string,
    voice?: string,
    model?: string,
    options?: Partial<AudioGenerationRequest>
  ): Promise<AudioGenerationResponse> {
    return this.generateAudio({
      input: text,
      voice,
      model,
      ...options
    });
  }

  private getFileExtension(contentType: string): string {
    const mapping: Record<string, string> = {
      'audio/mpeg': 'mp3',
      'audio/wav': 'wav',
      'audio/ogg': 'ogg',
      'audio/webm': 'webm'
    };
    return mapping[contentType] || 'mp3';
  }
}
```

### 6. Embedding Service (EmbeddingService.ts)

```typescript
import { BaseService } from './base/BaseService';
import { EmbeddingRequest, EmbeddingResponse } from '../types/embedding';

export class EmbeddingService extends BaseService {
  async createEmbedding(
    request: EmbeddingRequest
  ): Promise<EmbeddingResponse> {
    return this.makeRequest<EmbeddingResponse>('/v1/embeddings', {
      method: 'POST',
      body: JSON.stringify(request)
    });
  }

  // Convenience methods
  async embed(
    input: string | string[],
    model?: string,
    options?: Partial<EmbeddingRequest>
  ): Promise<EmbeddingResponse> {
    return this.createEmbedding({
      input,
      model,
      ...options
    });
  }

  async embedText(text: string, model?: string): Promise<number[]> {
    const response = await this.embed(text, model);
    return response.data[0]?.embedding || [];
  }

  async embedMultiple(texts: string[], model?: string): Promise<number[][]> {
    const response = await this.embed(texts, model);
    return response.data.map(item => item.embedding);
  }
}
```

### 7. Model Service (ModelService.ts)

```typescript
import { BaseService } from './base/BaseService';
import { Model } from '../types/models';

export class ModelService extends BaseService {
  async getModels(): Promise<Model[]> {
    return this.makeRequest<Model[]>('/public/models');
  }

  async getModelById(id: string): Promise<Model | null> {
    const models = await this.getModels();
    return models.find(model => model.id === id) || null;
  }

  async getModelsByCapability(capability: string): Promise<Model[]> {
    const models = await this.getModels();
    return models.filter(model => model.capabilities.includes(capability));
  }

  async getChatModels(): Promise<Model[]> {
    return this.getModelsByCapability('chat');
  }

  async getImageModels(): Promise<Model[]> {
    return this.getModelsByCapability('image-generation');
  }

  async getAudioModels(): Promise<Model[]> {
    return this.getModelsByCapability('text-to-speech');
  }

  async getEmbeddingModels(): Promise<Model[]> {
    return this.getModelsByCapability('embeddings');
  }
}
```

### 8. Type Definitions

#### Chat Types (types/chat.ts)
```typescript
export interface ChatMessage {
  role: 'system' | 'user' | 'assistant' | 'function';
  content: string;
  name?: string;
}

export interface ChatCompletionRequest {
  model?: string;
  messages: ChatMessage[];
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  n?: number;
  stream?: boolean;
  stop?: string | string[];
  presence_penalty?: number;
  frequency_penalty?: number;
  logit_bias?: Record<string, number>;
  user?: string;
}

export interface ChatCompletionResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: ChatMessage;
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
```

#### Image Types (types/image.ts)
```typescript
export interface ImageGenerationRequest {
  model?: string;
  prompt: string;
  n?: number;
  size?: string;
  width?: number;
  height?: number;
  quality?: 'standard' | 'hd';
  response_format?: 'url' | 'b64_json';
  style?: 'vivid' | 'natural';
}

export interface ImageGenerationResponse {
  created: number;
  data: Array<{
    url?: string;
    b64_json?: string;
    revised_prompt?: string;
  }>;
}
```

#### Audio Types (types/audio.ts)
```typescript
export interface AudioGenerationRequest {
  model?: string;
  input: string;
  voice?: string;
  response_format?: 'mp3' | 'opus' | 'aac' | 'flac';
  speed?: number;
}

export interface AudioGenerationResponse {
  audioBuffer: Buffer;
  contentType: string;
  filename: string;
}
```

#### Embedding Types (types/embedding.ts)
```typescript
export interface EmbeddingRequest {
  model?: string;
  input: string | string[];
  encoding_format?: 'float' | 'base64';
  dimensions?: number;
}

export interface EmbeddingResponse {
  object: string;
  data: Array<{
    object: string;
    embedding: number[];
    index: number;
  }>;
  model: string;
  usage: {
    prompt_tokens: number;
    total_tokens: number;
  };
}
```

### 9. Error Handling (errors/LunosError.ts)

```typescript
export class LunosError extends Error {
  public status: number;
  public code?: string;

  constructor(message: string, status: number = 0, code?: string) {
    super(message);
    this.name = 'LunosError';
    this.status = status;
    this.code = code;
  }
}

export class APIError extends LunosError {
  constructor(message: string, status: number) {
    super(message, status);
    this.name = 'APIError';
  }
}

export class ValidationError extends LunosError {
  constructor(message: string) {
    super(message, 400);
    this.name = 'ValidationError';
  }
}
```

### 10. Utility Classes

#### Streaming Utils (utils/streaming.ts)
```typescript
export class StreamProcessor {
  async processStream(
    stream: ReadableStream<Uint8Array>,
    onChunk?: (chunk: string) => void
  ): Promise<any> {
    const reader = stream.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            if (data === '[DONE]') {
              return { completed: true };
            }

            try {
              const parsed = JSON.parse(data);
              if (onChunk && parsed.choices?.[0]?.delta?.content) {
                onChunk(parsed.choices[0].delta.content);
              }
            } catch (e) {
              // Ignore parsing errors for incomplete chunks
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }

    return { completed: true };
  }
}
```

#### File Utils (utils/file.ts)
```typescript
import * as fs from 'fs';
import * as path from 'path';

export class FileUtils {
  static async saveBufferToFile(buffer: Buffer, filepath: string): Promise<void> {
    const dir = path.dirname(filepath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    return new Promise((resolve, reject) => {
      fs.writeFile(filepath, buffer, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  static async readFileAsBuffer(filepath: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      fs.readFile(filepath, (err, data) => {
        if (err) reject(err);
        else resolve(data);
      });
    });
  }

  static getFileExtension(filepath: string): string {
    return path.extname(filepath).slice(1);
  }
}
```

### 11. Main Export (index.ts)

```typescript
// Main client
export { LunosClient } from './client/LunosClient';

// Services
export { ChatService } from './services/ChatService';
export { ImageService } from './services/ImageService';
export { AudioService } from './services/AudioService';
export { EmbeddingService } from './services/EmbeddingService';
export { ModelService } from './services/ModelService';

// Types
export type {
  ChatMessage,
  ChatCompletionRequest,
  ChatCompletionResponse
} from './types/chat';

export type {
  ImageGenerationRequest,
  ImageGenerationResponse
} from './types/image';

export type {
  AudioGenerationRequest,
  AudioGenerationResponse
} from './types/audio';

export type {
  EmbeddingRequest,
  EmbeddingResponse
} from './types/embedding';

export type { Model } from './types/models';

// Errors
export { LunosError, APIError, ValidationError } from './errors/LunosError';

// Utils
export { StreamProcessor } from './utils/streaming';
export { FileUtils } from './utils/file';
```

## Usage Examples

### Basic Usage
```typescript
import { LunosClient } from '@lunos/client';

const client = new LunosClient({
  apiKey: 'your-api-key-here',
  baseUrl: 'https://api.lunos.tech'
});

// Chat completion
const response = await client.chat.createCompletion({
  model: 'openai/gpt-4',
  messages: [
    { role: 'user', content: 'Hello, how are you?' }
  ]
});

// Image generation
const image = await client.image.generate(
  'A beautiful sunset over mountains',
  'google/imagen-3.0'
);

// Audio generation
const audio = await client.audio.textToSpeech(
  'Hello, this is a test of text to speech.',
  'alloy',
  'openai/tts-1'
);

// Embeddings
const embedding = await client.embedding.embedText(
  'This is a sample text for embedding.',
  'openai/text-embedding-3-small'
);
```

### Streaming Chat
```typescript
let fullResponse = '';

const response = await client.chat.createCompletionWithStream(
  {
    model: 'openai/gpt-4',
    messages: [
      { role: 'user', content: 'Write a short story about a robot.' }
    ]
  },
  (chunk) => {
    fullResponse += chunk;
    process.stdout.write(chunk);
  }
);
```

### File Operations
```typescript
// Save audio to file
await client.audio.generateAudioToFile(
  {
    input: 'Hello world',
    voice: 'alloy',
    model: 'openai/tts-1'
  },
  './output/hello.mp3'
);
```

### Model Information
```typescript
// Get all models
const models = await client.models.getModels();

// Get chat models only
const chatModels = await client.models.getChatModels();

// Get specific model
const gpt4 = await client.models.getModelById('openai/gpt-4');
```

## Best Practices Implemented

1. **Error Handling**: Comprehensive error hierarchy with specific error types
2. **Type Safety**: Full TypeScript support with strict typing
3. **Streaming Support**: Built-in streaming for chat completions
4. **File Operations**: Utilities for saving generated content to files
5. **Configuration**: Flexible configuration with sensible defaults
6. **Retry Logic**: Automatic retry with exponential backoff
7. **Validation**: Input validation for all requests
8. **Documentation**: Comprehensive JSDoc comments
9. **Testing**: Designed for easy unit testing
10. **Extensibility**: Easy to add new services and capabilities

## Installation & Setup

```bash
npm install @lunos/client
```

```typescript
import { LunosClient } from '@lunos/client';

const client = new LunosClient({
  apiKey: process.env.LUNOS_API_KEY,
  timeout: 60000,
  retries: 3
});
```

This client library provides a clean, type-safe, and extensible interface to the Lunos API while following SOLID principles and best practices for maintainable code. 